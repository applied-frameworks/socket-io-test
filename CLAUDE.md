# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Socket.IO-based realtime collaborative canvas backend with JWT authentication. It enables multiple users to draw, add shapes, track cursors, and chat in realtime on shared canvases.

**Tech Stack**: Node.js, Express, Socket.IO, JWT, bcrypt, Prisma ORM

**Storage**: SQLite (local development), PostgreSQL (production ready)

## Development Commands

### Prerequisites
This project requires Node.js 22.x. If using nvm:
```bash
nvm use 22           # Switch to Node 22
```

### Running the Application
```bash
npm install          # Install dependencies
npm run db:push      # Sync database schema (first time setup)
npm start            # Start production server + client
npm run dev          # Start with nodemon (auto-reload) + client
```

### Database Commands
```bash
npm run db:push      # Push schema changes to database
npm run db:studio    # Open Prisma Studio (database GUI)
npm run db:generate  # Regenerate Prisma Client
npm run db:reset     # Reset database (deletes all data)
npm run db:seed      # Seed database with test users
```

### Database Seeding
The project includes a seed file (`prisma/seed.js`) that creates test users for development and testing:

**Test Users:**
- Admin: `admin` / `admin`
- User1: `user1` / `user1`
- User2: `user2` / `user2`

**Usage:**
```bash
npm run db:seed      # Create test users (idempotent - safe to run multiple times)
npx prisma db seed   # Alternative command
```

The seed script is **idempotent** - it checks if each user exists before creating them, so it's safe to run multiple times without duplicating data or affecting existing users.

### Testing Commands

**IMPORTANT**: UI tests require both the backend server (port 3000) and frontend client (port 8000) to be running.

```bash
# Start both servers before running tests (required for UI tests)
npm run dev          # In a separate terminal - starts backend + frontend

# Run all tests (API + UI)
npm test             # Runs all Playwright tests
npx playwright test  # Alternative command

# Run tests with UI mode
npm run test:ui      # Interactive test runner

# View test report
npm run test:report  # Open HTML test report
```

**Test Suites:**
- **API Tests** (`tests/auth.spec.js`): Authentication endpoints - can run without servers
- **UI Tests** (`tests/ui-auth-flow.spec.js`): Full signup/login flow - **requires servers running**

**Running Tests Workflow:**
1. Ensure database is set up: `npm run db:push`
2. Start dev servers: `npm run dev` (in separate terminal)
3. Wait for servers to be ready (backend on port 3000, frontend on port 8000)
4. Run tests: `npm test`

### Environment Setup
Create `.env` from `.env.example`:
```bash
PORT=3000
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
NODE_ENV=development
CLIENT_URL=http://localhost:8000
DATABASE_URL="file:./dev.db"  # SQLite for local dev
```

Generate a secure JWT secret:
```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

**For Production (PostgreSQL)**:
```bash
DATABASE_URL="postgresql://user:password@host:5432/dbname?schema=public"
```

### Health Check
```bash
curl http://localhost:3000/health  # Verify backend server is running
```

## Architecture

### Authentication Flow
1. **User Registration/Login** (`routes/auth.js`):
   - Passwords hashed with bcrypt (10 rounds)
   - JWT tokens issued with 7-day expiration
   - Tokens contain `{ userId, username }` payload

2. **HTTP Routes** (`middleware/auth.js:authenticateToken`):
   - Bearer token in `Authorization` header
   - Token verified and user attached to `req.user`

3. **Socket.IO Connections** (`middleware/auth.js:authenticateSocket`):
   - Token passed in `socket.handshake.auth.token`
   - User attached to `socket.user` before connection accepted
   - Authentication required for all WebSocket connections

### Data Management (Prisma + Hybrid Caching)

**Database Schema** (`prisma/schema.prisma`):
- **User**: Authentication and user data (persisted)
- **Canvas**: Canvas metadata (persisted)
- **Shape**: Persistent shapes on canvas (persisted)
- **DrawEvent**: Freehand drawing events, kept last 1000 (persisted)
- **CanvasUser**: Join table for tracking active users (not used, active users kept in-memory)

**User Store** (`services/userStore.js`):
- All methods are now `async` and use Prisma
- Methods: `createUser()`, `getUserById()`, `getUserByUsername()`, `updateLastLogin()`
- IDs generated by Prisma using `cuid()`

**Canvas Manager** (`services/canvasManager.js`) - Hybrid Approach:
- **Persisted**: Shapes, canvas metadata, draw events (buffered)
- **In-Memory**: Active users (cleared on restart), draw event buffer
- Draw events buffered in memory, flushed every 50 events or 10 seconds
- Automatic cleanup: canvases with no users for 24h are deleted (runs hourly)
- Methods are now `async`: `getCanvasState()`, `addShape()`, `updateShape()`, `deleteShape()`, `clearCanvas()`

### Socket.IO Event Flow

**Connection Lifecycle** (`server.js:57-199`):
1. Client connects with JWT → `authenticateSocket` middleware verifies
2. Server emits `user:connected` with userId and username
3. Client emits `canvas:join` with canvasId
4. Server responds with full `canvas:state` and `canvas:users` list
5. Other users in room receive `user:joined` notification

**Event Routing Pattern**:
- Client events are received, enriched with `userId`, `username`, `timestamp`
- Events broadcast to room using `socket.to(socket.currentCanvas).emit()`
- State updates persisted via `canvasManager` methods
- Chat messages use `io.to()` (includes sender) vs `socket.to()` (excludes sender)

**Current Canvas Tracking**:
- `socket.currentCanvas` stores the active canvas ID per connection
- Used for routing events to correct room
- Cleaned up in disconnect handler

### Key Design Decisions

1. **In-Memory Storage Singleton Pattern**: Both `userStore` and `canvasManager` export singleton instances. When migrating to a database, these modules should be replaced with database access layers while maintaining the same interface.

2. **Draw Event Buffering**: Draw events (freehand drawing) are stored separately from shapes. Only the last 100 draw events are sent on join, while all shapes are sent. This prevents overwhelming new joiners with historical drawing data.

3. **Security Layers**:
   - Helmet.js for HTTP security headers
   - Rate limiting: 100 requests per 15 minutes per IP on `/api/*` routes
   - CORS configured via `CLIENT_URL` environment variable
   - JWT verification on both HTTP and WebSocket connections

4. **Graceful Shutdown**: SIGTERM handler closes server cleanly (important for Heroku deployments)

## Socket.IO Events Reference

### Client → Server
- `canvas:join` - Join canvas room and receive state
- `draw:start/move/end` - Freehand drawing events
- `shape:add/update/delete` - Shape manipulation
- `canvas:clear` - Clear all shapes and draw events
- `cursor:move` - Update user cursor position
- `chat:message` - Send chat message

### Server → Client
- `user:connected` - Confirmation of successful auth
- `canvas:state` - Full canvas data on join
- `canvas:users` - Active users list
- `user:joined/left` - User presence notifications
- All drawing/shape events broadcast to room participants

## Deployment

This application can be deployed to multiple platforms. See detailed deployment guides in the `docs/` folder:

### AWS Elastic Beanstalk (Recommended)
- **Full guide**: [docs/AWS_DEPLOY.md](docs/AWS_DEPLOY.md)
- **GitHub Actions**: Automated deployment on push to `main` (`.github/workflows/deploy-aws.yml`)
- **Configuration**: See `.ebextensions/` and `.platform/` for Elastic Beanstalk settings
- **Database**: Supports AWS RDS PostgreSQL or SQLite
- **WebSocket**: Nginx configured for Socket.IO WebSocket upgrade

**Quick Setup:**
1. Set GitHub secrets: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`
2. Create Elastic Beanstalk application: `socket-io-canvas`
3. Create environment: `socket-io-canvas-dev`
4. Configure environment variables (JWT_SECRET, DATABASE_URL, CLIENT_URL, NODE_ENV)
5. Push to `main` branch - GitHub Actions handles deployment


**Port**: Reads from `process.env.PORT` (dynamically assigned by platform)

## PostgreSQL Migration (Production)

Migrating from SQLite to PostgreSQL is simple with Prisma:

1. **Update DATABASE_URL** in `.env` or production environment:
   ```bash
   DATABASE_URL="postgresql://user:password@host:5432/dbname?schema=public"
   ```

2. **Push schema to PostgreSQL**:
   ```bash
   npm run db:push
   ```

3. **No code changes needed** - Prisma handles the database differences

**Optional**: Update `prisma/schema.prisma` datasource for PostgreSQL-specific features:
```prisma
datasource db {
  provider = "postgresql"  // Change from "sqlite"
  url      = env("DATABASE_URL")
}
```

## Important Notes

- **Database**: SQLite for local dev (`prisma/dev.db`), PostgreSQL for production
- **Prisma Client**: Auto-generated after schema changes - run `npm run db:generate` if needed
- **Testing**: UI tests require both backend (port 3000) and frontend (port 8000) servers running via `npm run dev`
- JWT_SECRET and DATABASE_URL must be set in production
- Draw events persisted but limited to last 1000 per canvas
- Active users are in-memory only (not persisted to database)
- Socket.IO ping settings: 25s interval, 60s timeout (adjust for network conditions)
- Cleanup interval runs hourly - consider external cron in production
