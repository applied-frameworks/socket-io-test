# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Socket.IO-based realtime collaborative canvas backend with JWT authentication. It enables multiple users to draw, add shapes, track cursors, and chat in realtime on shared canvases.

**Tech Stack**: Node.js, Express, Socket.IO, JWT, bcrypt, Prisma ORM

**Storage**: SQLite (local development), PostgreSQL (production ready)

## Development Commands

### Prerequisites
This project requires Node.js 18.x. If using nvm:
```bash
nvm use 18           # Switch to Node 18
```

### Running the Application
```bash
npm install          # Install dependencies
npm run db:push      # Sync database schema (first time setup)
npm start            # Start production server + client
npm run dev          # Start with nodemon (auto-reload) + client
```

### Database Commands
```bash
npm run db:push      # Push schema changes to database
npm run db:studio    # Open Prisma Studio (database GUI)
npm run db:generate  # Regenerate Prisma Client
npm run db:reset     # Reset database (deletes all data)
```

### Environment Setup
Create `.env` from `.env.example`:
```bash
PORT=3000
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
NODE_ENV=development
CLIENT_URL=http://localhost:8000
DATABASE_URL="file:./dev.db"  # SQLite for local dev
```

Generate a secure JWT secret:
```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

**For Production (PostgreSQL)**:
```bash
DATABASE_URL="postgresql://user:password@host:5432/dbname?schema=public"
```

### Testing the Server
```bash
curl http://localhost:3000/health
```

## Architecture

### Authentication Flow
1. **User Registration/Login** (`routes/auth.js`):
   - Passwords hashed with bcrypt (10 rounds)
   - JWT tokens issued with 7-day expiration
   - Tokens contain `{ userId, username }` payload

2. **HTTP Routes** (`middleware/auth.js:authenticateToken`):
   - Bearer token in `Authorization` header
   - Token verified and user attached to `req.user`

3. **Socket.IO Connections** (`middleware/auth.js:authenticateSocket`):
   - Token passed in `socket.handshake.auth.token`
   - User attached to `socket.user` before connection accepted
   - Authentication required for all WebSocket connections

### Data Management (Prisma + Hybrid Caching)

**Database Schema** (`prisma/schema.prisma`):
- **User**: Authentication and user data (persisted)
- **Canvas**: Canvas metadata (persisted)
- **Shape**: Persistent shapes on canvas (persisted)
- **DrawEvent**: Freehand drawing events, kept last 1000 (persisted)
- **CanvasUser**: Join table for tracking active users (not used, active users kept in-memory)

**User Store** (`services/userStore.js`):
- All methods are now `async` and use Prisma
- Methods: `createUser()`, `getUserById()`, `getUserByUsername()`, `updateLastLogin()`
- IDs generated by Prisma using `cuid()`

**Canvas Manager** (`services/canvasManager.js`) - Hybrid Approach:
- **Persisted**: Shapes, canvas metadata, draw events (buffered)
- **In-Memory**: Active users (cleared on restart), draw event buffer
- Draw events buffered in memory, flushed every 50 events or 10 seconds
- Automatic cleanup: canvases with no users for 24h are deleted (runs hourly)
- Methods are now `async`: `getCanvasState()`, `addShape()`, `updateShape()`, `deleteShape()`, `clearCanvas()`

### Socket.IO Event Flow

**Connection Lifecycle** (`server.js:57-199`):
1. Client connects with JWT → `authenticateSocket` middleware verifies
2. Server emits `user:connected` with userId and username
3. Client emits `canvas:join` with canvasId
4. Server responds with full `canvas:state` and `canvas:users` list
5. Other users in room receive `user:joined` notification

**Event Routing Pattern**:
- Client events are received, enriched with `userId`, `username`, `timestamp`
- Events broadcast to room using `socket.to(socket.currentCanvas).emit()`
- State updates persisted via `canvasManager` methods
- Chat messages use `io.to()` (includes sender) vs `socket.to()` (excludes sender)

**Current Canvas Tracking**:
- `socket.currentCanvas` stores the active canvas ID per connection
- Used for routing events to correct room
- Cleaned up in disconnect handler

### Key Design Decisions

1. **In-Memory Storage Singleton Pattern**: Both `userStore` and `canvasManager` export singleton instances. When migrating to a database, these modules should be replaced with database access layers while maintaining the same interface.

2. **Draw Event Buffering**: Draw events (freehand drawing) are stored separately from shapes. Only the last 100 draw events are sent on join, while all shapes are sent. This prevents overwhelming new joiners with historical drawing data.

3. **Security Layers**:
   - Helmet.js for HTTP security headers
   - Rate limiting: 100 requests per 15 minutes per IP on `/api/*` routes
   - CORS configured via `CLIENT_URL` environment variable
   - JWT verification on both HTTP and WebSocket connections

4. **Graceful Shutdown**: SIGTERM handler closes server cleanly (important for Heroku deployments)

## Socket.IO Events Reference

### Client → Server
- `canvas:join` - Join canvas room and receive state
- `draw:start/move/end` - Freehand drawing events
- `shape:add/update/delete` - Shape manipulation
- `canvas:clear` - Clear all shapes and draw events
- `cursor:move` - Update user cursor position
- `chat:message` - Send chat message

### Server → Client
- `user:connected` - Confirmation of successful auth
- `canvas:state` - Full canvas data on join
- `canvas:users` - Active users list
- `user:joined/left` - User presence notifications
- All drawing/shape events broadcast to room participants

## Deployment

**Heroku**: Uses `Procfile` (`web: node server.js`)

Required config vars:
```bash
heroku config:set JWT_SECRET=<generated-secret>
heroku config:set NODE_ENV=production
heroku config:set CLIENT_URL=https://your-frontend-url.com
heroku config:set DATABASE_URL=<postgresql-connection-string>
```

**Port**: Reads from `process.env.PORT` (Heroku dynamically assigns this)

## PostgreSQL Migration (Production)

Migrating from SQLite to PostgreSQL is simple with Prisma:

1. **Update DATABASE_URL** in `.env` or production environment:
   ```bash
   DATABASE_URL="postgresql://user:password@host:5432/dbname?schema=public"
   ```

2. **Push schema to PostgreSQL**:
   ```bash
   npm run db:push
   ```

3. **No code changes needed** - Prisma handles the database differences

**Optional**: Update `prisma/schema.prisma` datasource for PostgreSQL-specific features:
```prisma
datasource db {
  provider = "postgresql"  // Change from "sqlite"
  url      = env("DATABASE_URL")
}
```

## Important Notes

- **Database**: SQLite for local dev (`prisma/dev.db`), PostgreSQL for production
- **Prisma Client**: Auto-generated after schema changes - run `npm run db:generate` if needed
- JWT_SECRET and DATABASE_URL must be set in production
- Draw events persisted but limited to last 1000 per canvas
- Active users are in-memory only (not persisted to database)
- Socket.IO ping settings: 25s interval, 60s timeout (adjust for network conditions)
- Cleanup interval runs hourly - consider external cron in production
